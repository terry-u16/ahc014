# AHC014日記

## 1日目（土）

問題を読んだ。なにこれ。むずすぎ。

点を4つ選ぶ問題、どこかで見たことあるな。 → [JOI2007本戦C 最古の遺跡](https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_c)。ベクトルを使うと便利そう。

点ごとの得点分布ってどうなるんだろ。伝家の宝刀†Excel†を使おうと思ったが、複数回使う機会がありそうなのでPythonの方が良いか。

可視化した。思った以上に四隅のウェイトが大きい。中心付近はほぼ無価値。ちまちま伸ばすというよりは四隅を取りに行くゲームか？

ビジュアライザにmanual modeがあったので手でやってみる。むっず。合法手がどこかもぱっと見だと分からないな。端まで伸ばすとかそういうことを考える余裕がない。適当な貪欲を書いた方が早そう。

点を配置できる場所を考える。ある印の付いていない点p_0を起点に、u方向とv方向に伸ばして点p_1, p_2を見つける。そこからさらに伸ばして、他の点や線分にぶつからずにp_3が見つかればOK。N≦64だからビット演算で高速化できそうだが、斜めの処理がめんどくさそう。ビット演算はとりあえず後回しにして、今日はまず貪欲を完成させることを目標にしよう。

貪欲解を作った。長方形を構築可能な頂点の中から最も重みの大きいものを選ぶだけ。33.2Mで3位。これ外側目指すの難しすぎるな。縦横→斜め→縦横→斜め→……の順で伸ばしていくのだろうか……。

テストケースを捏造して遊んでみる。2本のラインを作って、そこから□と◇を無限に作れると強そう。

強化学習とかできたりする？いやむずそうだけど……。

盤面がデカいんだよなあ。計算量がConv2D 1回あたりΩ(N^2 K^2 C_in C_out)くらいかかるのでヤバそう。

ABCに参加。ギリギリGまで解けた。コンテスト中の橙diffは5回目なので嬉しい。

## 2日目（日）

案の定1位はもう50M点超えてる。長期コンの序盤の点数はアテにならない……。

[Magic Bitboard](https://ipsj.ixsq.nii.ac.jp/ej/index.php?active_action=repository_view_main_item_detail&page_id=13&block_id=8&item_id=71312&item_no=1)というものがあるらしい。メモっておく。まあとりあえずはRotated Bitboardで十分かな。多分書き込みより読み込みの方が多いし。

実装だるすぎてスーパーマリオサンシャインのRTAを観てしまい3時間を消費。攻略本片手に120枚集めた思い出。

どうにか実装。座標変換で頭がこわれそうになったけど思ったほどバグらなかった。サーバ上での実行時間は455ms→119msに短縮。満足……とまではいかないが、まあ4倍速くなったのは大きい。

クラウド実行環境の初期設定をした。 `dotnet tool install` でお手軽にできるようになったのでだいぶ良い。が、設定ファイルの書き方とか忘れてるな。どこかに書き残しておこう。

とりあえず合法手を絶やさないことが大事なゲームなんだろうか。うーん……。

何も考えていないビームを撃った。弱い。ダメだなあ。

選択確率に重みを付けつつ時間いっぱい乱択するやつを作った。37.6Mで28位。こっちの方がまだマシだけど未来がない……。

新しい点の配置候補を列挙するとき、(x, y)で全探索するよりも今存在する点を全探索した方が速くなることにようやく気付いた。修正。

seed=98で1,000,000点を超えていた。見ると□と◇を交互にたくさん作れている。やっぱりこういう形を作り出せると強いっぽい。

## 3日目（月）

乱択貪欲をするときに大きな長方形を選ぶのを避けるようにするとスコアが上がった。40.64Mで18位。言われてみれば確かにという感じだけど、常にこれが正しいのかは謎。

```text
  +
 +
+ * ←なんかここ強いっぽい ←ごめん嘘かも
```

「実は1箇所90°回転させると2つの輪っかを1つにくっつけられます」みたいな天才パズルが求められている？

人間がこういうパズル解くときどうするだろ。DFSっぽくある程度のところまで行って、ダメそうだったら手順を戻して繰り返す？同じような山登りができない？

やってみた。結構伸びた。山登りができるということは焼きなましもできるということなので焼く。43.18Mで13位。こういう焼き方は初めてだなあ。勉強になる。

上手くいっているケース（seed=98）を見ると、1個置いたあとそこから連鎖的に繋げていっている。こういう手を優先するようにすると強い？

1x1の□→1x1の◇→それ以外の順に優先していくようにした。ちょい伸び。

早くも頭打ち感が出てきた。このままやってもあまり期待できなさそうだし、レート上げるなら一発にかける必要があるので強化学習で行けないかチャレンジしてみるか。

[OpenAI Gym／Baselines 深層学習・強化学習 人工知能プログラミング 実践入門](https://amzn.to/3qLWhsI)を買った（今更？）。この人の本、[AlphaZero 深層学習・強化学習・探索 人工知能プログラミング実践入門](https://amzn.to/3Un9aqE)は読んだことがあってかなり良かったんだよな。勉強が間に合うか、間に合っても上手く行くかどうかよく分からないけどやってみる。

ざっと流し読みした。モデルが既知なのにモデルフリーの手法を適用するのはあまり筋が良い方法ではない気がしてきた。今のコードの何が良くないかというと、先読みができないんだよなこれ。MCTS……とまでは行かないが、何かしらの先読みは取り入れたい。

そういえばと思って高速化を行った。合法手の列挙を毎回行うのではなく、新しく可能となった手のみを差分追加するというもの。非合法となった手がゴミとなってたくさん残るが、別に害はないので放っておいてよい。提出すると50.47Mで5位。

今まで合法手の列挙が計算時間のボトルネックになっていたが、今度はランダムサンプリングが計算時間のボトルネックになった。重みの累積和の更新に毎回Θ(N)かかるためで、これはFenwick-Treeを使えば高速化できる。

実行時間を10倍にすると10%くらいスコアが改善しそうだったので、やる。等倍～3倍くらいになった。3%ほどの伸び。

雑な先読み入れてみたけど微妙……なんか伸びそうなビジョンが見えないなあ。

今の焼きなましはランダムなターン数目以降を全部捨てているけど、全部捨てるのはなんかもったいない気がするな。1要素ごとにランダムに残すか捨てるか決めるようにしてみるか。

なんか死ぬほど良くなった。20%も改善とか言われると真っ先にスコア計算バグを疑うんだけど、公式ジャッジツール使ってるから間違ってはいないはず……？投げる。[61.80Mで2位](https://twitter.com/terry_u16/status/1571862645762068483)。マジか。これ焼けるとか嘘だろ……。

焼けるのが信じられなくて「凄いよこの問題……」と言い続けてる。絶対ビームサーチ問だと思ったんだけど。いやビームサーチでも解けるのかもしれないけど。手順間の依存関係が強くて焼きなましは筋が悪いように見えたのだけれど、言われてみればある点が消えることで影響を受ける箇所は意外と少ないのかもしれない。

実行時間を10倍にすれば70M超えるらしい。高速化かあ……。

「ランダムに残すか捨てるか決める」の確率を時間経過で変更させるようにした。63.32M。今日はここまでにするかね。

## 4日目（火）

TODO: 近くにある点を探すとき、主ベクトル+従ベクトルの2つ×8方向を調べていて無駄なのでキャッシュする。

やった。2割くらい速くなった。64.54M。

ちょっと高速化に限界を感じてきた。焼きなましが正解だと決めつけずにもっと色々な可能性を探るべきか……。

まだコンテストの1/4が終わった段階なんだよなあ。同じ2週間コンテストの[AHC008の順位表](https://iilj.github.io/AtCoderMarathonReplay/#/standings/ahc008/2022-02-15T19:00:00+0900)を見ると、開始3日目時点のぶっちぎり1位の点数で1ページ目にすら入れていないんだよな。70M点は目指さないとダメか……。

メモ：実行時間を10倍にしたら73M相当くらい。高速化するか探索を効率化するか……。

## 5日目（水）

飲み会あった上に人身事故で電車が大幅遅延したので何もできませんでした。終わり。

と思うじゃん？AHC欲から逃れられるわけがないんだよな。辺の状態を8方向持っていて冗長だったやつを4方向に減らした。そこそこ効いて、これで2割程度の高速化。提出しても伸びなかったけど手元では2%ほど伸びてる。

1x1がたくさん作れるケースは高速化でOK、そうでないケースは？

1点も伸びないのはなんか悔しいのでサブミットガチャして65.30M。ごめん……。

## 6日目（木）

有望そうな頂点を優先的に探索するとかできない？履歴をもとにベイズ推定とか。

多スタートをやって、なんか効果なさそうだったからやめた。

焼きなまし中にどんな状態になってるか見たいな。お手製ビジュアライザ作るか……？

点数が伸びないケースはどうなってる？（2日連続2回目） → 1x1を優先しない方が良いケースもありそう。レアケースだが。

Rafbillさんが72Mに乗せてた。ぐえーキツい……。下からも突き上げられていて3連休が思いやられる。

## 7日目（金）

生成される長方形はDAGになるので、トポソしてランダムに順番を変えるとかしてみる？ → いや頂点間の依存関係は変わってないから意味ないか……。

実行時間を2倍にすると5%くらい良くなりそう。うーん高速化……。高速化するならプロファイリングをすべきで、Linux環境である必要がありそう？

ビジュアライザを作った。png画像をたくさん作ってFFmpegで.mp4に変換。自分用に真面目に作ったのは初めてかも。[Yukicoderでスコア問題を出題した](https://yukicoder.me/contests/396)経験が活きた。やっぱ焼きなまし中の過程が見られるのは良いね。

今はランダムに長方形を消しているけど、ある領域に存在する長方形をまとめて消した方が良い気がする。左端と右端を消してもあまり意味がないので。

予想通りめっちゃ伸びた。68.04Mで2位復帰。ビジュアライザ大事。

## 8日目（土）

高速化できるところがあったので、した。部分破壊した後に長方形を置けるか確認する際、頂点2,3,4だけ見れば良くて特に辺の有無の確認は不要。1割くらい速くなった。68.83M。

メモ: kick近傍を検討する。

□で消すだけでなく、◇で消すやつも入れた。ついでに長方形は禁止して正方形のみにした。70.47M。ついに70Mに乗ったので嬉しい。

乱択貪欲時に重み付きサンプリングを行っていたが、重みなしでもよい気がしたのでそうした。重み累積和計算用のFenwick Treeが不要になり、追加・削除がΘ(logN)からΘ(1)になった。72.14M。思ったより効いた。やはり高速化は正義……。

プロファイリングを行おうと思ったけれど、WSLだとperfがそのまま使えないらしい。[perfを手動でビルドする](https://stackoverflow.com/questions/60237123/is-there-any-method-to-run-perf-under-wsl)ことはできたものの、なんだか上手く行かず。どうやらWindowsではそんな凝ったことをしなくても[普通にVisual Studioをプロセスにアタッチ](https://www.reddit.com/r/rust/comments/hrqr36/cpu_profiling_on_windows/)すればいいらしい。C#でプロファイリングをやったことはあるけど、一般のプロセスでもこんな感じでプロファイリングできるのか。

プロファイリングの結果、N, Mが大きいseed=5では長方形の追加処理が1/4くらいを占めているらしい。内部でベクトルの座標変換やbit演算を行っているので、改善するならここか。現状でもそれなりに考えてO(1)で各種処理を行えるようにはなっているので、より高速化するとなると難しいな。考えるだけ考えておく。

ベクトルを180°・90°・45°回転させるときのif文、上手くやるとANDとORに変換してif文が消せますね～となったがやってみたら2倍近く遅くなった。マジか。インライン展開がされなくなったということもなさそうだったので不思議なのだけれど、もしかしてコンパイラが天才的な展開をしてたりする？それとも単純に条件分岐がそんなに遅くないか、乗算が遅いか……。

手動#\[inline\]指示を消したら微妙に速くなったっぽい。こういうのはコンパイラ様に判断を任せた方が良いらしい。

やれることが少なくなってきた。貪欲パートを賢くする？どうやって……？

外側に近い点から優先度付きキューで優先的に追加していく？

ABCに出た。Fまでは30分だったけどGが全く分からなかった。Baby-step Giant-stepかあ……。名前だけは聞いたことがあるのだけれど。

改修を見越してリファクタリング。トレイトとかイテレータとか使って抽象化した。あとコードの一部をモジュールにぶち込んだら速度が遅くなったように見える。なんだろこれ。

## 9日目（日）

ようやく折り返し。2週間コンテスト、楽しいけどしんどい……。

長方形を作成するところはもっと高速化できそうだったのでやってみたが、全然上手く行かない。そもそも元々の仕様があやふやなのがダメだな。後でやる。

> 外側に近い点から優先度付きキューで優先的に追加していく？

これをやったが、微妙。m/n^2が小さいケースでは上手くいってそうなのだが、そういうケースに絞って適用するようにしてもなぜか全体的に速度が下がった。多分昨日のやつと同じ現象で、謎。

高速化が上手く行かない原因が分かったので修正。微妙に速くなってはいそうだが、ほとんど変わらず。追加した処理もまあまあ重いからな……。Vecへの長方形のpushが全体の8%とかを占めている程度には高速化されているので、これ以上速くするのは厳しいか……。

ツール周りを整備する。まずテストケースを並列で回すやつがクラウドのみ対応でローカルで回せなかったので（なぜ？）回せるようにした。次に結果をjsonで吐き出せると嬉しいので機能を追加した。パラメータ調整の時とかに役に立つはず。

とか言ってたらbowwowforeachさんに抜かれた。まあ想定内。Rafbillさん以上の点数を出してきたらアレだったけど、だいたい同じくらいなのでまだ希望はありそう。下振れでこれだったりしたらキツいけど。

`&impl T` を `&dyn T` にしたら1割高速化された（というか遅くなったのが元に戻った）。えぇ……。人間の理解の範疇を超えているが、バイナリサイズの肥大化が悪影響を及ぼしていたり、キャッシュに乗らなくてダメだったりするのかもしれない。他にも `[#Inline]` を付けたら3割くらい遅くなったケースもあった。

近傍で領域を破壊する度にstateを一から作り直してるけど、これ多分重いな。cloneしてから削除した方が良さそう。実装すると3割くらい速くなった。これは大きい。スコアも2%強伸びた。72.60M。

提出が30回を超えた。こいつ提出しすぎだろ。

3位が自分で72.60M、4位が68.16M。さすがに1桁順位は確定したと信じたい。あと6日……。

## 10日目（月）

そもそも貪欲単体で強くすべきではないか。焼きなましは一旦忘れて貪欲を作り、optunaでパラメータ調整？

どういうケースに改善余地があるかチェック。仕事中に実行時間x1, x2, x10でそれぞれ10000ケースずつ回しておいたので、それぞれの得点差が大きいケースがどの辺りか見ていく。

まず、実行時間と1ケースあたりの平均得点は以下のようになった。

|実行時間|平均得点|
|-------|--------|
|1倍    |1.474M  |
|2倍    |1.532M  |
|10倍   |1.641M  |

なんとなくは察していたが、めちゃくちゃ伸びしろがあるな。さすがに順位表の1位が80Mに達することはないだろうけれど、75Mとかは普通に出てくるだろうなあ。

スコアをグラフにプロットした。Nの大きさとスコアの相関はそんなに大きくなくて、M/N^2（以下、密度）とスコアの相関はかなり大きそう。またNは大きい方が、密度は高い方が実行時間を伸ばしたときの改善幅が大きい。予想通りと言えば予想通りではあるが、Nが大きく高密度なケースをターゲットとした改善を考えるのが良さそう。もっとも低密度ケースでも伸びる方法があるのかもしれないが、今から考えるのはコスパが悪い。

[Ryzen 7000シリーズのレビュー記事](https://ascii.jp/elem/000/004/106/4106507/)が流れてきたので読んだ。7950Xの性能凄いな……。数%変わる程度ならそこまででもないのだけれど、CINEBENCHの結果を見る限り数割という単位で変わっている。ちょうど今マラソンでマルチテストケースをぶん回しているのでかなり欲しい。

今使っている3950Xとコア数は同じなのだけれど、AtCoderサーバとイテレーション回数を同じにするなら実行時間を短くできるので、テストケースを速く回せるようになる。さっと回すにはクラウド上が良いのだけれど、長時間パラメータチューニングする場合はクラウド上だと大変なことになるのでローカルで回したいのよね。

領域を破壊する際、完全ランダムで闇雲に破壊するよりは□から生える4つの△の根元を破壊した方が良いのではないか？と思ったが、微妙だった。ボツ。

ある点から8方向に頂点を探しに行くやつが重いので、高速化した……つもりが遅くなってしまった。結構頑張ったがうーん……。やっぱりもう高速化は厳しいのかなあ。

貪欲中に次の頂点を候補内からランダムに選ぶとき、通常は1x1の長方形を優先して選ぶようにしているが、初手に限り1x1以外の長方形も選ぶようにした。密度が小さいケースに効くはず（さっきの方針と真逆なのですが……）。1%ほど伸びた。72.92M。

しかし仕事終わってから6時間AHCやって進捗がこれなのヤバいな。闇のゲーム。

## 11日目（火）

メモ：破壊する頂点を矩形領域ではなくBFSするのはどうか。

メモ：焼きなましスコアにsqrtをかけるのはどうか。

メモ：「一定期間更新されていなかったらロールバック」をイテレーション回数ではなく時間で判断するようにしてはどうか。

お仕事が終わったのでロールバックからやる。現状では「10000イテレーションの間過去最高スコアを更新しなかったらロールバック」としているが、それを変更する。まずは適当に5000イテレーションにすると0.5M/caseほど伸びた。これを回数ではなく時間で判断する。焼きなまし全体を1単位時間として、0.1単位時間更新がなかったらロールバックするようにした。だいたい5000イテレーションと同じくらい。どっちでも変わらない感が凄いけれど、とりあえずこれで行くか。

次はスコアにsqrtをかけるやつ。点のスコアは外周に行くほど2乗で増え、また大きな三角形ができるとそれも大きさの2乗なので、それを壊してしまったときのスコア減少が激しく、局所解にハマりやすい気がする。そこでsqrtをかけて緩和することにする。いろいろ調整したところ、だいたい1M/caseほど伸びた。

気付いたらbowwowforeachさんが76.31Mを出している。ひえー。やっぱり強いな……。75Mは普通に出てきそうと言ったけど、こんなに早いとは思ってなかった。こちらも提出。73.97M。とりあえず暫定2位に浮上。

焼きなましの近傍操作時に破壊する頂点をBFSする。矩形領域破壊だとスパースなテストケースで上手く行かないのでは？と思ったため。実装すると目に見えてスコアが悪化した。BFSに乱択を入れてもダメ。イテレーション回数はそんなに変わらないので、単純に破壊する場所の筋が悪そう。ボツ。

焼きなましの近傍操作で破壊後の再構築を行う際、2回再構築を行ってより良い方を選ぶようにした。破壊後の候補点列挙が重く、再構築は言うほど重くないため、これで実質的な高速化を狙う。0.5M/caseほど伸びていそう？提出すると74.70M。手元では10000ケースで1.51M/caseくらい出ている。暫定ケースがちょい厳しめと考えるとこんなもんか。

ひさびさにseed=0を回してみたらついに100万点が出たので[記念ツイート](https://twitter.com/terry_u16/status/1574785571066589184)。コンテスト始めた頃はまさかこんな点数出るとは思ってなかった……。

そろそろパラメータチューニングの準備をする。(N, M) のペアに対して最適な温度ペア (T0, T1) を求めたい。(N, M)ペアごとにoptunaという手もあるが、今回は(N, M/N^2, T0, T1) を入力としてスコアを予測する関数を作る。なんだかよく分からないので今回もNNに任せることにする。NNの無駄使いな気もするが、まあ最小二乗法のお化けみたいなものと考えればいいか。

ランダムな温度を入力して焼きなましを実行しスコアを記録するプログラムを作った。10000ケースが30分で回るので、一晩回せばまあそこそこのデータが集まるはず。もう2時半になってしまった。寝よう。

## 12日目（水）

お仕事終わって見てみたら21万ケースくらい回ってた。クソ多いな。

コーディングしている裏で、そういえば焼きなまし中のスコアにsqrt()かけてるやつを取ってみたらどうだろうと10000ケース回してみる。1.516M/case。sqrt()かけてるやつより0.006M/caseほど良くなってないか。こっちで回した方が良かったかなあ。

NNを作る。かなり適当で、(dense 4x16 → relu) → (dense 16x16 → relu)x3 → (dense 16x1) という構成。まあ最小二乗法がしたいだけだし。最初出力が1だらけになっていて1時間ほど溶かしたが、最終層にsigmoid噛ませていたせいだった。アホ。

モデルができたのでRust側を書く。といってもコードはほとんど[AHC008](https://www.terry-u16.net/entry/ahc008)の流用。base64デコーディングで死ぬほどバグらせた記憶があるのでありがたい。10000ケース回してみる。劇的な効果はなかったが、0.01M/caseの改善。明日は温度にsqrt付けないパターンでもやってみよう。寝ている間に3950Xくんに頑張ってもらう。

## 13日目（木）

sqrt付けないパターンのものをNNに学習させる。が、上手く予測できていない。スコアのブレが大きすぎるのか？うーん。

sqrt版に戻す。非sqrt版をやる中で、最終層にsigmoidを噛ませた方が精度が上がることに気付いたのでやっぱり付ける。スコアを0～3Mと仮定すればよい。0.005M/caseほどの改善。

再構築回数を3回にしたら若干スコアが上がった。また再構築時にVecを毎回生成せず使い回すようにしたら速くなった。

少しでも速度が欲しいので、配列の境界チェックを外していく。もちろんunsafe。外した方が有意に速くなるレベルまで来てしまった。異常unsafeコードができた。

また破壊領域の調整も行う。ランダムな矩形内に点が50個以上あったら再抽選としていたものを30個以上に変更。

以上を実施すると0.025M/caseほど改善した。投げると75.81M。bowwowforeachさんが76.31Mなのでかなり近付いてきたが、向こうも伸ばしてくるだろうからまだまだ足りないなあ……。

> 貪欲中に次の頂点を候補内からランダムに選ぶとき、通常は1x1の長方形を優先して選ぶようにしているが、初手に限り1x1以外の長方形も選ぶようにした
。

これ、seed=5とかでは逆効果になっているな。1000回平均で0.1Mほど悪化する。これもパラメータチューニングの対象にしよう。PCぶん回して寝る。
